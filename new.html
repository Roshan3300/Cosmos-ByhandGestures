<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hand-Tracked Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* Main 3D Canvas */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* Camera Feed (Bottom Right) */
        .camera-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            z-index: 10;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        #video-input { transform: scaleX(-1); width: 100%; height: 100%; object-fit: cover; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 5;
            pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; text-shadow: 0 0 10px #00ffff; }
        p { font-size: 0.9rem; opacity: 0.8; }
        .status { color: #00ff00; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Gesture Particles</h1>
        <p>üñê <b>Open Palm:</b> Switch Shape</p>
        <p>ü§è <b>Pinch:</b> Expand / Explode</p>
        <p>üëã <b>Move Hand:</b> Rotate & Color</p>
        <p>Current Shape: <span id="shape-name" class="status">Loading...</span></p>
    </div>

    <div id="canvas-container"></div>

    <div class="camera-container">
        <video id="video-input" autoplay playsinline></video>
    </div>

    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const CAM_WIDTH = 640;
        const CAM_HEIGHT = 480;

        // --- Global Variables ---
        let scene, camera, renderer, points;
        let originalPositions, targetPositions;
        let handLandmarker;
        let currentShapeIndex = 0;
        let lastShapeSwitchTime = 0;
        let isPinching = false;
        let pinchDistance = 0;
        let handCentroid = { x: 0, y: 0 };
        
        const shapes = ['Sphere', 'Heart', 'Saturn', 'Flower', 'Torus'];
        const shapeEl = document.getElementById('shape-name');

        // --- Initialization ---
        async function init() {
            initThree();
            setupShapes('Sphere');
            await initMediaPipe();
            animate();
        }

        // --- Three.js Setup ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // Soft fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Particle Geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            // Initialize arrays for morphing
            originalPositions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                colors[i * 3] = 1;
                colors[i * 3 + 1] = 1;
                colors[i * 3 + 2] = 1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Shader Material for nice glowing dots
            const textureLoader = new THREE.TextureLoader();
            const sprite = textureLoader.load('https://threejs.org/examples/textures/sprites/disc.png');

            const material = new THREE.PointsMaterial({
                size: 0.6,
                map: sprite,
                vertexColors: true,
                alphaTest: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            window.addEventListener('resize', onWindowResize);
        }

        // --- Shape Generation Logic (Templates) ---
        function getShapeCoordinates(type) {
            const coords = new Float32Array(PARTICLE_COUNT * 3);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let x, y, z;

                if (type === 'Sphere') {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = 15;
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } 
                else if (type === 'Heart') {
                    // 3D Heart formula
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    // Distribute mainly on surface but some volume
                    const r = 1.2; 
                    x = 16 * Math.pow(Math.sin(theta), 3) * Math.cos(phi);
                    y = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                    z = 6 * Math.pow(Math.sin(theta), 3) * Math.sin(phi); // Extrude Z
                } 
                else if (type === 'Saturn') {
                    const r = Math.random();
                    if (r < 0.7) { // Planet
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                        const rad = 10;
                        x = rad * Math.cos(theta) * Math.sin(phi);
                        y = rad * Math.sin(theta) * Math.sin(phi);
                        z = rad * Math.cos(phi);
                    } else { // Rings
                        const angle = Math.random() * Math.PI * 2;
                        const rad = 14 + Math.random() * 8;
                        x = rad * Math.cos(angle);
                        y = Math.random() * 0.5; // Thin vertically
                        z = rad * Math.sin(angle);
                        
                        // Tilt ring
                        const tilt = 0.4;
                        const oldY = y;
                        y = oldY * Math.cos(tilt) - z * Math.sin(tilt);
                        z = oldY * Math.sin(tilt) + z * Math.cos(tilt);
                    }
                }
                else if (type === 'Flower') {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    const r = 15 * Math.sin(3*u) * Math.sin(v); // 3 petals
                    x = r * Math.sin(u) * Math.cos(v);
                    y = r * Math.sin(u) * Math.sin(v);
                    z = r * Math.cos(u);
                }
                else if (type === 'Torus') {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    const R = 15;
                    const r = 5;
                    x = (R + r * Math.cos(v)) * Math.cos(u);
                    y = (R + r * Math.cos(v)) * Math.sin(u);
                    z = r * Math.sin(v);
                }

                coords[idx] = x;
                coords[idx + 1] = y;
                coords[idx + 2] = z;
            }
            return coords;
        }

        function setupShapes(type) {
            shapeEl.innerText = type;
            const newCoords = getShapeCoordinates(type);
            
            // Set targets
            for(let i=0; i<newCoords.length; i++) {
                targetPositions[i] = newCoords[i];
            }
        }

        // --- MediaPipe Hand Tracking ---
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const video = document.getElementById("video-input");
            
            // Get Camera
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    detectHands(video);
                });
            }
        }

        function detectHands(video) {
            async function loop() {
                if (video.currentTime > 0) {
                    const results = handLandmarker.detectForVideo(video, performance.now());
                    handleGestures(results);
                }
                requestAnimationFrame(loop);
            }
            loop();
        }

        function handleGestures(results) {
            if (results.landmarks && results.landmarks.length > 0) {
                const lm = results.landmarks[0]; // First hand

                // 1. Calculate Hand Centroid (for Rotation/Color)
                // Using Wrist(0) and Middle Finger MCP(9) approx center
                const cx = (lm[0].x + lm[9].x) / 2; 
                const cy = (lm[0].y + lm[9].y) / 2;
                
                // Mirror X for intuitive interaction
                handCentroid.x = (1 - cx) * 2 - 1; // Range -1 to 1
                handCentroid.y = -(cy * 2 - 1);    // Range -1 to 1

                // 2. Pinch Detection (Thumb Tip 4 & Index Tip 8)
                const dx = lm[4].x - lm[8].x;
                const dy = lm[4].y - lm[8].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // 3. Open Palm Detection (for switching shapes)
                // Check if fingers are extended relative to wrist
                const isPalmOpen = lm[8].y < lm[5].y && lm[12].y < lm[9].y && lm[16].y < lm[13].y && lm[20].y < lm[17].y;
                
                if (isPalmOpen && Date.now() - lastShapeSwitchTime > 2000) {
                    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    setupShapes(shapes[currentShapeIndex]);
                    lastShapeSwitchTime = Date.now();
                }

                // Map Pinch Distance to Expansion Factor
                // Threshold ~0.05 is touching, 0.3 is wide open
                pinchDistance = Math.max(0, (dist - 0.05) * 5); // Normalized roughly 0 to 1+
                isPinching = dist < 0.1;
            } else {
                // Reset defaults if no hand
                pinchDistance = 0.5; // Default idle float
                handCentroid.x *= 0.95; // Decay back to center
                handCentroid.y *= 0.95;
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (!points) return;

            const positions = points.geometry.attributes.position.array;
            const colors = points.geometry.attributes.color.array;
            const time = Date.now() * 0.001;

            // Base Rotation based on hand position
            points.rotation.y += 0.002 + (handCentroid.x * 0.05);
            points.rotation.x += (handCentroid.y * 0.05);

            // Expansion Factor (Pinch)
            // If fingers close, expand (explosion effect), if open, compact
            const expansion = 1 + (1 - pinchDistance) * 3; // 1 to 4

            // Color Hue Shift based on hand X position
            const hueShift = (handCentroid.x + 1) / 2; // 0 to 1
            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = i * 3;
                const py = i * 3 + 1;
                const pz = i * 3 + 2;

                // 1. Lerp Position towards Target Shape
                // Soft lerp for organic movement
                const lerpSpeed = 0.05;
                positions[px] += (targetPositions[px] - positions[px]) * lerpSpeed;
                positions[py] += (targetPositions[py] - positions[py]) * lerpSpeed;
                positions[pz] += (targetPositions[pz] - positions[pz]) * lerpSpeed;

                // 2. Apply Expansion (Visual effect only, doesn't change stored position)
                // We add a noise factor for "Fireworks" vibe when expanded
                const noise = isPinching ? (Math.random()-0.5) * 0.5 : 0;
                
                const finalX = positions[px] * expansion + noise;
                const finalY = positions[py] * expansion + noise;
                const finalZ = positions[pz] * expansion + noise;

                // We write directly to buffer, but we need to account for expansion logic
                // Actually, modifying the buffer directly accumulates error if not careful.
                // Better approach: Keep 'positions' as the base shape state, 
                // but since we want to modify the actual render, we might need a shader or 
                // just overwrite the buffer relative to target.
                // Simpler CPU approach: Move current POS towards Target, then multiply for display? 
                // No, three.js buffer is the display. 
                
                // Hybrid: We update positions towards target, but push them out based on expansion
                // To prevent permanent drifting, we only Lerp towards target. 
                // The expansion effect is applied by modifying the geometry attribute temporarily? 
                // No, that's slow. Let's just modify the Lerp target dynamically.
                
                let tx = targetPositions[px] * expansion;
                let ty = targetPositions[py] * expansion;
                let tz = targetPositions[pz] * expansion;

                // Add some noise/jitter
                tx += Math.sin(time + px) * 0.2;
                ty += Math.cos(time + py) * 0.2;

                positions[px] += (tx - positions[px]) * 0.1;
                positions[py] += (ty - positions[py]) * 0.1;
                positions[pz] += (tz - positions[pz]) * 0.1;

                // 3. Update Colors
                // Base color based on position + hand hue override
                const h = (i / PARTICLE_COUNT + hueShift + time * 0.1) % 1;
                colorObj.setHSL(h, 0.8, 0.6);
                
                colors[px] = colorObj.r;
                colors[py] = colorObj.g;
                colors[pz] = colorObj.b;
            }

            points.geometry.attributes.position.needsUpdate = true;
            points.geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>